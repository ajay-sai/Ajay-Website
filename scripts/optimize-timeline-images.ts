import sharp from "sharp";
import fs from "node:fs/promises";
import path from "node:path";
import { fileURLToPath } from "node:url";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const projectRoot = path.resolve(__dirname, "..");

const SOURCE_DIR = path.join(projectRoot, "public", "images", "timeline");
const OUTPUT_DIR = path.join(SOURCE_DIR, "optimized");
const MANIFEST_PATH = path.join(
  projectRoot,
  "client",
  "src",
  "data",
  "timeline-image-map.ts",
);

const RESPONSIVE_WIDTHS = [480, 960, 1600];
const PLACEHOLDER_WIDTH = 32;
const QUALITY = 75;

const allowedExtensions = new Set([".jpg", ".jpeg", ".png", ".webp", ".jfif", ".pjpeg", ".pjp", ".bmp", ".tiff", ".gif"]);

interface ResponsiveSource {
  width: number;
  fileName: string;
}

interface ManifestEntry {
  defaultSrc: string;
  srcSet: string;
  placeholder: string;
  width: number;
  height: number;
  aspectRatio: number;
}

const ensureDirectory = async (dir: string) => {
  await fs.mkdir(dir, { recursive: true });
};

const getImageFiles = async (): Promise<string[]> => {
  const entries = await fs.readdir(SOURCE_DIR);
  return entries
    .filter((entry) => allowedExtensions.has(path.extname(entry).toLowerCase()))
    .sort();
};

const buildSrcSet = (sources: ResponsiveSource[]): string => {
  return sources.map((source) => `/images/timeline/optimized/${source.fileName} ${source.width}w`).join(", ");
};

const formatManifestFile = (manifest: Record<string, ManifestEntry>): string => {
  const header = `// Auto-generated by scripts/optimize-timeline-images.ts\n// Do not edit manually\n\nexport interface TimelineImageSource {\n  defaultSrc: string;\n  srcSet: string;\n  placeholder: string;\n  width: number;\n  height: number;\n  aspectRatio: number;\n}\n\nexport const TIMELINE_IMAGE_MAP: Record<string, TimelineImageSource> = `;
  const body = JSON.stringify(manifest, null, 2);
  return `${header}${body} as const;\n`;
};

const optimizeImages = async () => {
  console.time("optimize-timeline-images");
  await ensureDirectory(OUTPUT_DIR);

  const files = await getImageFiles();
  if (files.length === 0) {
    console.warn("No source images found in", SOURCE_DIR);
    return;
  }

  const manifest: Record<string, ManifestEntry> = {};

  for (const fileName of files) {
    const sourcePath = path.join(SOURCE_DIR, fileName);
    const fileBaseName = path.parse(fileName).name;
    const relativeKey = `timeline/${fileName}`;

    const metadata = await sharp(sourcePath).metadata();
    const originalWidth = metadata.width ?? Math.max(...RESPONSIVE_WIDTHS);
    const originalHeight = metadata.height ?? Math.max(...RESPONSIVE_WIDTHS);

    const sources: ResponsiveSource[] = [];

    for (const width of RESPONSIVE_WIDTHS) {
      if (originalWidth < width && sources.length > 0) {
        // Skip generating larger than original after at least one variant exists
        continue;
      }

      const outputFileName = `${fileBaseName}-w${width}.webp`;
      const outputPath = path.join(OUTPUT_DIR, outputFileName);

      await sharp(sourcePath)
        .resize({ width, withoutEnlargement: true })
        .webp({ quality: QUALITY, effort: 5 })
        .toFile(outputPath);

      sources.push({ width, fileName: outputFileName });
    }

    if (sources.length === 0) {
      throw new Error(`No responsive sources generated for ${fileName}`);
    }

    // Generate placeholder
    const placeholderBuffer = await sharp(sourcePath)
      .resize({ width: PLACEHOLDER_WIDTH, withoutEnlargement: true })
      .webp({ quality: 40 })
      .toBuffer();
    const placeholder = `data:image/webp;base64,${placeholderBuffer.toString("base64")}`;

    const preferredDefault = sources.find((src) => src.width === 960);
    const defaultSource = preferredDefault ?? sources[sources.length - 1];

    const aspectRatio =
      originalWidth && originalHeight
        ? originalWidth / originalHeight
        : 1.5;

    const targetWidth = defaultSource.width;
    const targetHeight = Math.round(targetWidth / aspectRatio);

    manifest[relativeKey] = {
      defaultSrc: `/images/timeline/optimized/${defaultSource.fileName}`,
      srcSet: buildSrcSet(sources),
      placeholder,
      width: targetWidth,
      height: targetHeight,
      aspectRatio,
    };

    console.log(`Optimized ${fileName} -> ${sources.length} variants`);
  }

  const manifestDir = path.dirname(MANIFEST_PATH);
  await ensureDirectory(manifestDir);
  await fs.writeFile(MANIFEST_PATH, formatManifestFile(manifest));

  console.timeEnd("optimize-timeline-images");
};

optimizeImages().catch((error) => {
  console.error("Failed to optimize timeline images", error);
  process.exitCode = 1;
});
